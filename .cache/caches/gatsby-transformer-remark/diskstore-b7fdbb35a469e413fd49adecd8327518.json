{"expireTime":9007200800480545000,"key":"transformer-remark-markdown-html-b423695f5e5bc84185f7366902249e01-gatsby-remark-prismjsgatsby-remark-katexgatsby-remark-images-","val":"<h2>Introduction</h2>\n<blockquote>\n<p>Function pointers are literally pointers to functions.</p>\n</blockquote>\n<p>Function pointers are just what their name suggests, they are pointers to functions! In particular, a function pointer points to code (rather than data like what we are normally used to) and stores the start of executable code. Let’s just get straight to some code.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">void print_stuff(int a)\n{\n  printf(&quot;Hi there, I am %d\\n&quot;, a);\n}\n\nint main()\n{\n  // Pointer is void type and points to print_stuff function.\n  // (int) lets us know what TYPE are the arguments for the function.\n  void (*func_ptr)(int) = &amp;print_stuff;\n  \n  // To call the function, we go:\n  (*func_ptr)(20);\n  // Here, we dereferenced the pointer and also passed in inputs for it.\n  // Note this also works even if we removed the *\n}</code></pre></div>\n<blockquote>\n<p>Hi there, I am 20</p>\n</blockquote>\n<p>Note that when we declared our function pointer, it is extremely important that we have those brackets around *func_ptr or else it will be confused for a declaration of a function that returns void pointers. </p>\n<p>A clearer illustration of when we would use a function pointer would be when we don’t know what the functions are at compile time.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n\n// Here we declare a function.\nvoid do_stuff(int x);\n\nint main()\n{\n    void (*func_ptr)(int) = &amp;do_stuff;\n    (*func_ptr)(4);\n}\n\nvoid do_stuff(int x)\n{\n  printf(&quot;Done stuff with %d\\n&quot;,x);\n}</code></pre></div>\n<blockquote>\n<p>Done stuff with 4</p>\n</blockquote>\n<p>So why else might we be bothered with function pointers?</p>\n<ul>\n<li>Efficiency</li>\n<li>Elegance</li>\n<li>Runtime binding whereby we can change the function up depending on what we feed the function at runtime</li>\n</ul>\n<p>Note that with these pointers, we do not need to de-allocate memory as we are not pointing to memory.</p>\n<hr>\n<p>Here's another example just to drill this home:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">// Our function\nint add_numbers(int x, int y)\n{\n  return x + y;\n}\n\n// Our FUNCTION POINTER:\nint (*func_ptr)(int, int);\n\n// Again, this points to a function that returns an int and takes in 2 ints as arguments.\n\n// Now to point it to a function:\nfunc_ptr = &amp;add_numbers;\n\n// To actually use this function pointer:\nint sum = (*func_ptr)(5, 10);\n\n// Here, we dereference our function pointer and pass in our arguments for the function.\n\n// Altenrative\nint sum = func_ptr(5, 10);</code></pre></div>\n<h2>Summary</h2>\n<p>Function pointers are just an address referring to an area of memory with executable code.</p>"}