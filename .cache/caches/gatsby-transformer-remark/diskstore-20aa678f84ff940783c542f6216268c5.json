{"expireTime":9007200800480522000,"key":"transformer-remark-markdown-html-a520120a7926420ca7e7b0d56bed68e2-gatsby-remark-prismjsgatsby-remark-katexgatsby-remark-images-","val":"<h2>Introduction</h2>\n<p>A file is just a sequence of bytes. Everything in UNIX is a file. This is profoundly deep idea. Text files are files, directories are files, even commands like ls or pwd are just files. </p>\n<p>Disk storage allows us to provide persistent storage. The OS abstracts this to be known as files. These files are arranged into a tree by folder/directory structure. Whenever we want to read or write to a file, we do this through system calls.</p>\n<p>The applications that the user interacts with are \"managed\" by the OS which then helps us interface with the hardware. Here, the OS doesn't trust the user and doesn't give them direct access to the hardware. System calls are ways for programs to talk to the hardware and through these system calls, we can set standards on how we want these interactions to occur.</p>\n<p>For files, they aren't necessarily stored in contiguous memory but in fact distributed across the disk containing information on them. Devices themselves are also represented as files.</p>\n<hr>\n<h3>Files</h3>\n<p>A FILE is a struct that is defined in &#x3C;stdio.h>. We have that feof() helps test whether are we at the end of file indicator. </p>\n<p>When we read stuff in, they can be either buffered (input/output accumulated into a block then passed) or unbuffered where we just pass input/output on right away.</p>\n<h3>File Pointers</h3>\n<p>File helps to store persistent data! Hence, when we terminate programs, we can still have information relating to the stuff we just did in that program. All file manipulation functions are inside &#x3C;stdio.h>.  All of these require file pointers as arguments.</p>\n<h4>fopen</h4>\n<p>fopen(): This opens a file and returns a file pointer to it. We can check the return value of this and if it is NULL, then that means that file does not exist. Hence, we pass in a file and an operation we want to undertake.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">FILE* fp = fopen(&lt;filename&gt;, &lt;operation&gt;);\n\n// Operation can be &quot;w&#39;, &quot;r&quot;, &quot;wb&quot;, &quot;a&quot; etc depending on what mode you want to operate the file in.</code></pre></div>\n<p>We now have a pointer called fp that points to our file.</p>\n<p>When we begin a program, special files are opened for us. These files are:</p>\n<ol>\n<li>stdin</li>\n<li>stdout</li>\n<li>stderr</li>\n</ol>\n<h4>fclose</h4>\n<p>Takes in a file pointer and closes the file. You should do this to be safe.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">fclose(&lt;file pointer&gt;);</code></pre></div>\n<h4>fgetc</h4>\n<p>This means file, get a character. Get the next character of that file and store it into a variable.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">char our_char = fgetc(&lt;file pointer&gt;);\n\n// Example\nchar our_char = fgetc(fp);</code></pre></div>\n<p>In order for this to work, we should've have already opened the file pointer. Hence, we get the next character from our file.</p>\n<p>Hence, with these 3 operations, we can now open a file and read in everything from it character by character:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">FILE *fp = fopen(&quot;my_file.txt&quot;, &quot;r&quot;);\n\nchar ch;\nwhile((ch = fgetc(fp)) != EOF)\n{\n  printf(&quot;%c\\n&quot;, ch);\n}</code></pre></div>\n<p>This will keep getting the next character and printing it as long as it is not the EOF character. This is actually what the linux command cat does!</p>\n<h4>fputc</h4>\n<p>This is the equivalent to writing/appending specific character to a file that's being pointed to. Note that the file pointer we pass in must be in either write or append more!</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">fputc(&lt;character&gt;, &lt;file pointer&gt;);\n\n// Example\nfputc(&#39;c&#39;, fp);</code></pre></div>\n<p>So now we can copy contents from one file over into another file using this new command to help us!</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">FILE *fp = fopen(&quot;my_file.txt&quot;, &quot;r&quot;);\n\nchar ch;\nwhile((ch = fgetc(fp)) != EOF)\n{\n  fputc(ch, fp_two);\n}</code></pre></div>\n<p>This writes it out into another file pointer! This is the cp command in linux!</p>\n<h4>fread</h4>\n<p>This is similar to fgetc except now it's a generic form in which we can get <em>any</em> amount of information we want. This reads in a quantity of memory where each is a certain size and stores them into a buffer.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">fread(&lt;buffer&gt;, &lt;size&gt;, &lt;qty&gt;, &lt;file pointer&gt;);\n// Note that file pointer must be in read mode!!</code></pre></div>\n<p>Hence, an example could be, read 6 \"things\" of size 4 bytes each into a buffer. Hence, this is effectively asking us to read in 6 ints into our buffer as an int is 4 bytes. Hence, we can now read in an arbitrary amount of things and stores it into a buffer.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">int arr[10];\nfread(arr, sizeof(int), 10, file_pointer);</code></pre></div>\n<p>Hence, this allows us to read in 10*sizeof(int) amount of information from the file_pointer and storing that temporarily into our buffer arr. Recall arr (an array) is just a pointer to the first element in our array and hence we are passing in a pointer when we do this. We could also pass in something that has been malloc'd for our buffer.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">double *arr2 = malloc(sizeof(double) * 80); // Creates an array of 80 elements.\nfread(arr2, sizeof(double), 80, file_pointer); // Reads in 80 doubles from our file and temporarily stores it into our buffer.\n\n// If we wanted to store it into a buffer like a character, then we need to do &amp;character_variable.</code></pre></div>\n<h4>fwrite</h4>\n<p>This is similar to fputc but now generic size! Similar idea to fread.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">int arr[10];\nfwrite(arr, sizeof(int), 10, ptr);\n// Note that ptr must be in write or append mode only.\n// Don&#39;t forget to flush too.\nfflush(ptr);</code></pre></div>\n<h4>fseek</h4>\n<p>This allows you to move forward and backwards through the file.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">fseek(&lt;file pointer&gt;, &lt;offset&gt;, &lt;whence&gt;)\n\n// An example to go to the end of the file is\n\nfseek(fp, 0, SEEK_END); // We are now at the end!\n\nfseek(fp, 0, SEEK_SET); // Move to start of the file!\n\nlong position = 10;\nfseek(fp, position, SEEK_SET); // Move to position &quot;position&quot; 10 in the file</code></pre></div>\n<h4>ftell</h4>\n<p>This tells us where in the file we currently are. In particular, it gives you the byte position we are currently at.</p>\n<h4>rewind</h4>\n<p>This allows us to rewind back to the start of the file!</p>\n<h4>ferror</h4>\n<p>Indicates whether an error has occurred in working with the file.</p>\n<h4>fgets</h4>\n<p>Reads one line of input and returns a string.</p>\n<h4>fflufsh</h4>\n<p>Input Stream: Disard any data in the buffer that has not been processed yet.\nOutput Stream: Force write all the data in the buffer. Make sure everything has been written out.</p>\n<hr>\n<h4>File Descriptors</h4>\n<p>Every time we open a file, there is a file descriptor. This is just a non-negative integer associated with the file. This descriptor describes the state of the file i.e whether is it opened or close. File descriptors helps us keep track of things.</p>\n<p>Hence, we also have commands such as:</p>\n<h4>Write</h4>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">write(int fildes, buf, size_t num_bytes);</code></pre></div>\n<p>Hence, if we wanted to print something to stdout</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">write(1, &quot;Hello!&quot;, 7);\n// Recall 1 is write/stdout</code></pre></div>\n<h4>Read</h4>\n<p>This is the same ideas as writing but now we can read in from stdin.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">read(int fildes, void *buf, size_t nbyte);\n// Same idea as writing\n\nchar buf[5];\nread(0, buf, 4);</code></pre></div>"}